// Auto-generated FFI bindings for ExecuTorch Flutter C wrapper.
// DO NOT EDIT - regenerate using: dart run ffigen
//
// Generated from: src/c_wrapper/executorch_flutter_wrapper.h
// Configuration: ffigen.yaml

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Auto-generated FFI bindings for ExecuTorch Flutter C wrapper
class ExecutorchFfiBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  ExecutorchFfiBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  ExecutorchFfiBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// @brief Get human-readable error code name
  ///
  /// @param code Error code
  /// @return Constant string describing the error code (e.g., "ET_FLUTTER_SUCCESS")
  /// Returns "UNKNOWN_ERROR_CODE" for invalid codes
  ///
  /// @note The returned string is constant and should not be freed
  ffi.Pointer<ffi.Char> et_flutter_error_code_name(
    ETFlutterErrorCode code,
  ) {
    return _et_flutter_error_code_name(
      code.value,
    );
  }

  late final _et_flutter_error_code_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'et_flutter_error_code_name');
  late final _et_flutter_error_code_name = _et_flutter_error_code_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// @brief Load an ExecuTorch model from a file path
  ///
  /// This function loads a .pte model file, validates it, and returns a handle
  /// that can be used for inference operations. The model remains loaded until
  /// explicitly disposed via et_flutter_dispose_model() or automatically freed
  /// by Dart's NativeFinalizer.
  ///
  /// @param file_path Absolute path to a .pte model file (null-terminated UTF-8)
  /// @return Load result containing model handle and error information
  ///
  /// @note The returned model_handle must be freed via et_flutter_dispose_model()
  /// @note If error.code != ET_FLUTTER_SUCCESS, model_handle will be NULL
  ///
  /// @par Thread Safety
  /// This function is not thread-safe. Call from a single thread only.
  ///
  /// @par Example
  /// @code
  /// ETFlutterLoadResult result = et_flutter_load_model("/path/to/model.pte");
  /// if (result.error.code != ET_FLUTTER_SUCCESS) {
  /// fprintf(stderr, "Load failed: %s\n", result.error.message);
  /// return;
  /// }
  /// // Use result.model_handle for inference...
  /// et_flutter_dispose_model(result.model_handle);
  /// @endcode
  ETFlutterLoadResult et_flutter_load_model(
    ffi.Pointer<ffi.Char> file_path,
  ) {
    return _et_flutter_load_model(
      file_path,
    );
  }

  late final _et_flutter_load_modelPtr = _lookup<
          ffi
          .NativeFunction<ETFlutterLoadResult Function(ffi.Pointer<ffi.Char>)>>(
      'et_flutter_load_model');
  late final _et_flutter_load_model = _et_flutter_load_modelPtr
      .asFunction<ETFlutterLoadResult Function(ffi.Pointer<ffi.Char>)>();

  /// @brief Run inference on a loaded model
  ///
  /// This function executes the model's forward pass with the provided input tensors
  /// and returns output tensors. The input tensor data is read (zero-copy) but not
  /// modified or freed. Output tensor data is allocated by this function and must be
  /// freed by calling et_flutter_free_forward_output().
  ///
  /// @param model_handle Handle to a loaded model (from et_flutter_load_model)
  /// @param input Input tensor data (Dart owns, C reads only)
  /// @return Forward output containing result tensors and error information
  ///
  /// @note Caller must call et_flutter_free_forward_output() to free output memory
  /// @note If error.code != ET_FLUTTER_SUCCESS, num_outputs will be 0
  ///
  /// @par Thread Safety
  /// This function is not thread-safe. Do not call simultaneously with the same model_handle.
  ///
  /// @par Example
  /// @code
  /// ETFlutterForwardInput input = { .num_inputs = 1, .inputs = {&tensor} };
  /// ETFlutterForwardOutput output = et_flutter_forward(model_handle, &input);
  /// if (output.error.code != ET_FLUTTER_SUCCESS) {
  /// fprintf(stderr, "Inference failed: %s\n", output.error.message);
  /// return;
  /// }
  /// // Use output.outputs[0]->data...
  /// et_flutter_free_forward_output(&output);
  /// @endcode
  ETFlutterForwardOutput et_flutter_forward(
    ETFlutterModelHandle model_handle,
    ffi.Pointer<ETFlutterForwardInput> input,
  ) {
    return _et_flutter_forward(
      model_handle,
      input,
    );
  }

  late final _et_flutter_forwardPtr = _lookup<
      ffi.NativeFunction<
          ETFlutterForwardOutput Function(ETFlutterModelHandle,
              ffi.Pointer<ETFlutterForwardInput>)>>('et_flutter_forward');
  late final _et_flutter_forward = _et_flutter_forwardPtr.asFunction<
      ETFlutterForwardOutput Function(
          ETFlutterModelHandle, ffi.Pointer<ETFlutterForwardInput>)>();

  /// @brief Dispose a loaded model and free associated resources
  ///
  /// This function frees all memory associated with the model handle, including
  /// internal ExecuTorch module data. After calling this function, the model_handle
  /// becomes invalid and must not be used again.
  ///
  /// @param model_handle Handle to dispose (from et_flutter_load_model)
  ///
  /// @note It is safe to pass NULL (no-op)
  /// @note Calling with an already-disposed handle is undefined behavior
  /// @note This function does not return an error (best-effort cleanup)
  ///
  /// @par Thread Safety
  /// This function is not thread-safe. Do not call simultaneously with the same model_handle.
  ///
  /// @par Example
  /// @code
  /// et_flutter_dispose_model(model_handle);
  /// model_handle = NULL;  // Prevent accidental reuse
  /// @endcode
  void et_flutter_dispose_model(
    ETFlutterModelHandle model_handle,
  ) {
    return _et_flutter_dispose_model(
      model_handle,
    );
  }

  late final _et_flutter_dispose_modelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ETFlutterModelHandle)>>(
          'et_flutter_dispose_model');
  late final _et_flutter_dispose_model = _et_flutter_dispose_modelPtr
      .asFunction<void Function(ETFlutterModelHandle)>();

  /// @brief Free output tensors allocated by et_flutter_forward()
  ///
  /// This function frees all memory allocated for output tensors, including
  /// tensor data buffers and metadata structures. After calling this function,
  /// the output pointer and all nested pointers become invalid.
  ///
  /// @param output Pointer to output structure (from et_flutter_forward)
  ///
  /// @note It is safe to pass NULL (no-op)
  /// @note Calling with already-freed output is undefined behavior
  /// @note This function does not return an error (best-effort cleanup)
  ///
  /// @par Example
  /// @code
  /// ETFlutterForwardOutput output = et_flutter_forward(model_handle, &input);
  /// // Copy output data to Dart...
  /// et_flutter_free_forward_output(&output);
  /// @endcode
  void et_flutter_free_forward_output(
    ffi.Pointer<ETFlutterForwardOutput> output,
  ) {
    return _et_flutter_free_forward_output(
      output,
    );
  }

  late final _et_flutter_free_forward_outputPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ETFlutterForwardOutput>)>>(
      'et_flutter_free_forward_output');
  late final _et_flutter_free_forward_output =
      _et_flutter_free_forward_outputPtr
          .asFunction<void Function(ffi.Pointer<ETFlutterForwardOutput>)>();

  /// @brief Get the size in bytes of a tensor data type
  ///
  /// @param dtype Tensor data type
  /// @return Size in bytes (e.g., 4 for FLOAT32, 1 for UINT8)
  /// Returns 0 for invalid types
  ///
  /// @par Example
  /// @code
  /// size_t element_size = et_flutter_dtype_size(ET_FLUTTER_DTYPE_FLOAT32);  // 4
  /// @endcode
  int et_flutter_dtype_size(
    ETFlutterDataType dtype,
  ) {
    return _et_flutter_dtype_size(
      dtype.value,
    );
  }

  late final _et_flutter_dtype_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.UnsignedInt)>>(
          'et_flutter_dtype_size');
  late final _et_flutter_dtype_size =
      _et_flutter_dtype_sizePtr.asFunction<int Function(int)>();

  /// @brief Get human-readable name of a tensor data type
  ///
  /// @param dtype Tensor data type
  /// @return Constant string (e.g., "float32", "int8")
  /// Returns "unknown" for invalid types
  ///
  /// @note The returned string is constant and should not be freed
  ffi.Pointer<ffi.Char> et_flutter_dtype_name(
    ETFlutterDataType dtype,
  ) {
    return _et_flutter_dtype_name(
      dtype.value,
    );
  }

  late final _et_flutter_dtype_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'et_flutter_dtype_name');
  late final _et_flutter_dtype_name = _et_flutter_dtype_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// @brief Calculate total number of elements in a tensor shape
  ///
  /// @param shape Pointer to tensor shape
  /// @return Total element count (product of all dimensions)
  /// Returns 0 if shape is NULL or invalid
  ///
  /// @par Example
  /// @code
  /// ETFlutterTensorShape shape = { .num_dims = 4, .dims = {1, 3, 224, 224} };
  /// size_t count = et_flutter_shape_element_count(&shape);  // 150528
  /// @endcode
  int et_flutter_shape_element_count(
    ffi.Pointer<ETFlutterTensorShape> shape,
  ) {
    return _et_flutter_shape_element_count(
      shape,
    );
  }

  late final _et_flutter_shape_element_countPtr = _lookup<
          ffi.NativeFunction<
              ffi.Size Function(ffi.Pointer<ETFlutterTensorShape>)>>(
      'et_flutter_shape_element_count');
  late final _et_flutter_shape_element_count =
      _et_flutter_shape_element_countPtr
          .asFunction<int Function(ffi.Pointer<ETFlutterTensorShape>)>();

  /// @brief Validate tensor data for correctness
  ///
  /// Validates that:
  /// - Shape has valid dimensions (1-8 dims, all positive)
  /// - Data type is valid
  /// - Data pointer is not NULL
  /// - Data size matches shape and dtype
  ///
  /// @param tensor Pointer to tensor data
  /// @param error Output error structure (populated on failure)
  /// @return ET_FLUTTER_SUCCESS on success, error code on failure
  ///
  /// @par Example
  /// @code
  /// ETFlutterError error;
  /// if (et_flutter_validate_tensor(&tensor, &error) != ET_FLUTTER_SUCCESS) {
  /// fprintf(stderr, "Invalid tensor: %s\n", error.message);
  /// }
  /// @endcode
  ETFlutterErrorCode et_flutter_validate_tensor(
    ffi.Pointer<ETFlutterTensorData> tensor,
    ffi.Pointer<ETFlutterError> error,
  ) {
    return ETFlutterErrorCode.fromValue(_et_flutter_validate_tensor(
      tensor,
      error,
    ));
  }

  late final _et_flutter_validate_tensorPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<ETFlutterTensorData>,
              ffi.Pointer<ETFlutterError>)>>('et_flutter_validate_tensor');
  late final _et_flutter_validate_tensor =
      _et_flutter_validate_tensorPtr.asFunction<
          int Function(
              ffi.Pointer<ETFlutterTensorData>, ffi.Pointer<ETFlutterError>)>();

  /// @brief Get library version string
  ///
  /// @return Constant version string (e.g., "1.0.0")
  ///
  /// @note The returned string is constant and should not be freed
  ffi.Pointer<ffi.Char> et_flutter_version() {
    return _et_flutter_version();
  }

  late final _et_flutter_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'et_flutter_version');
  late final _et_flutter_version =
      _et_flutter_versionPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();
}

/// mbstate_t is an opaque object to keep conversion state, during multibyte
/// stream conversions.  The content must not be referenced by user programs.
final class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  /// for alignment
  @ffi.LongLong()
  external int _mbstateL;
}

final class __darwin_pthread_handler_rec extends ffi.Struct {
  /// Routine to call
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  /// Argument to pass
  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

final class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

/// @brief Error codes returned by C wrapper functions
///
/// These error codes map to the following Dart exceptions:
/// - ET_FLUTTER_SUCCESS → (no exception)
/// - ET_FLUTTER_ERROR_MODEL_LOAD → ExecuTorchModelException
/// - ET_FLUTTER_ERROR_INFERENCE → ExecuTorchInferenceException
/// - ET_FLUTTER_ERROR_VALIDATION → ExecuTorchValidationException
/// - ET_FLUTTER_ERROR_MEMORY → ExecuTorchMemoryException
/// - ET_FLUTTER_ERROR_IO → ExecuTorchIOException
/// - ET_FLUTTER_ERROR_PLATFORM → ExecuTorchPlatformException
/// - ET_FLUTTER_ERROR_INVALID_HANDLE → ExecuTorchModelException
/// - ET_FLUTTER_ERROR_INVALID_ARGUMENT → ExecuTorchValidationException
enum ETFlutterErrorCode {
  /// Operation completed successfully
  ET_FLUTTER_SUCCESS(0),

  /// Model loading failed (file not found, invalid format, memory mapping error, etc.)
  ET_FLUTTER_ERROR_MODEL_LOAD(1),

  /// Inference execution failed (invalid inputs, runtime error, backend error, etc.)
  ET_FLUTTER_ERROR_INFERENCE(2),

  /// Tensor validation failed (wrong shape, incompatible type, dimension mismatch, etc.)
  ET_FLUTTER_ERROR_VALIDATION(3),

  /// Memory allocation failed or out of memory
  ET_FLUTTER_ERROR_MEMORY(4),

  /// File I/O operation failed (read error, write error, permission denied, etc.)
  ET_FLUTTER_ERROR_IO(5),

  /// Platform-specific error (JNI error, framework error, unsupported platform, etc.)
  ET_FLUTTER_ERROR_PLATFORM(6),

  /// Invalid model handle (null pointer, disposed model, corrupted handle, etc.)
  ET_FLUTTER_ERROR_INVALID_HANDLE(7),

  /// Invalid argument passed to function (null pointer, out of range, etc.)
  ET_FLUTTER_ERROR_INVALID_ARGUMENT(8);

  final int value;
  const ETFlutterErrorCode(this.value);

  static ETFlutterErrorCode fromValue(int value) => switch (value) {
        0 => ET_FLUTTER_SUCCESS,
        1 => ET_FLUTTER_ERROR_MODEL_LOAD,
        2 => ET_FLUTTER_ERROR_INFERENCE,
        3 => ET_FLUTTER_ERROR_VALIDATION,
        4 => ET_FLUTTER_ERROR_MEMORY,
        5 => ET_FLUTTER_ERROR_IO,
        6 => ET_FLUTTER_ERROR_PLATFORM,
        7 => ET_FLUTTER_ERROR_INVALID_HANDLE,
        8 => ET_FLUTTER_ERROR_INVALID_ARGUMENT,
        _ =>
          throw ArgumentError("Unknown value for ETFlutterErrorCode: $value"),
      };
}

/// @brief Tensor element data types
enum ETFlutterDataType {
  /// 32-bit floating point (IEEE 754 single precision)
  ET_FLUTTER_DTYPE_FLOAT32(0),

  /// 32-bit signed integer
  ET_FLUTTER_DTYPE_INT32(1),

  /// 8-bit signed integer
  ET_FLUTTER_DTYPE_INT8(2),

  /// 8-bit unsigned integer
  ET_FLUTTER_DTYPE_UINT8(3);

  final int value;
  const ETFlutterDataType(this.value);

  static ETFlutterDataType fromValue(int value) => switch (value) {
        0 => ET_FLUTTER_DTYPE_FLOAT32,
        1 => ET_FLUTTER_DTYPE_INT32,
        2 => ET_FLUTTER_DTYPE_INT8,
        3 => ET_FLUTTER_DTYPE_UINT8,
        _ => throw ArgumentError("Unknown value for ETFlutterDataType: $value"),
      };
}

/// @brief Error structure containing code and message
final class ETFlutterError extends ffi.Struct {
  /// Error code (ET_FLUTTER_SUCCESS on success)
  @ffi.UnsignedInt()
  external int code;

  /// Human-readable error message (UTF-8 encoded, null-terminated)
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> message;
}

/// @brief Tensor shape information
final class ETFlutterTensorShape extends ffi.Struct {
  /// Number of dimensions (1-8)
  @ffi.Int32()
  external int num_dims;

  /// Size of each dimension (e.g., [1, 3, 224, 224] for NCHW image)
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Int64> dims;
}

/// @brief Tensor data passed between Dart and C
///
/// Memory ownership depends on context:
/// - For inputs (Dart → C): Dart owns data, C reads only
/// - For outputs (C → Dart): C allocates, Dart copies, C frees
final class ETFlutterTensorData extends ffi.Struct {
  /// Tensor shape (dimensions)
  external ETFlutterTensorShape shape;

  /// Element data type
  @ffi.UnsignedInt()
  external int dtype;

  /// Pointer to tensor data (ownership depends on context)
  external ffi.Pointer<ffi.Void> data;

  /// Size of data buffer in bytes
  @ffi.Size()
  external int data_size;

  /// Optional tensor name (null-terminated UTF-8, can be NULL)
  @ffi.Array.multi([64])
  external ffi.Array<ffi.Char> name;
}

/// @brief Result of model loading operation
final class ETFlutterLoadResult extends ffi.Struct {
  /// Error information (code == ET_FLUTTER_SUCCESS on success)
  external ETFlutterError error;

  /// Opaque handle to loaded model (NULL on error)
  external ETFlutterModelHandle model_handle;

  /// Model file path (copy of input path, for debugging)
  @ffi.Array.multi([512])
  external ffi.Array<ffi.Char> file_path;
}

/// @brief Opaque handle to a loaded ExecuTorch model
///
/// This is a pointer to internal model data managed by the C wrapper.
/// Dart code should treat this as an opaque Pointer<Void>.
typedef ETFlutterModelHandle = ffi.Pointer<ffi.Void>;

/// @brief Input tensors for forward pass
final class ETFlutterForwardInput extends ffi.Struct {
  /// Number of input tensors (1-16)
  @ffi.Int32()
  external int num_inputs;

  /// Array of input tensor pointers (Dart owns data, C reads only)
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Pointer<ETFlutterTensorData>> inputs;
}

/// @brief Output tensors from forward pass
final class ETFlutterForwardOutput extends ffi.Struct {
  /// Error information (code == ET_FLUTTER_SUCCESS on success)
  external ETFlutterError error;

  /// Number of output tensors (0 on error)
  @ffi.Int32()
  external int num_outputs;

  /// Array of output tensor pointers (C allocates, Dart must free)
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Pointer<ETFlutterTensorData>> outputs;
}

const int __has_safe_buffers = 1;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __has_bounds_safety_attributes = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int NULL = 0;

const int USER_ADDR_NULL = 0;

const int __WORDSIZE = 64;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int ET_FLUTTER_MAX_TENSOR_DIMS = 8;

const int ET_FLUTTER_MAX_INPUTS = 16;

const int ET_FLUTTER_MAX_OUTPUTS = 16;

const int ET_FLUTTER_ERROR_MESSAGE_MAX_LEN = 256;

const int ET_FLUTTER_TENSOR_NAME_MAX_LEN = 64;

const int ET_FLUTTER_FILE_PATH_MAX_LEN = 512;
